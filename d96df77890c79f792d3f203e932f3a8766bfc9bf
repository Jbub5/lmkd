{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "31e456ad_41555326",
        "filename": "reaper.cpp",
        "patchSetId": 6
      },
      "lineNbr": 167,
      "author": {
        "id": 1584799
      },
      "writtenOn": "2021-12-28T23:59:08Z",
      "side": 1,
      "message": "Shouldn\u0027t you call mutex_.unlock() before returning?",
      "range": {
        "startLine": 167,
        "startChar": 15,
        "endLine": 167,
        "endChar": 20
      },
      "revId": "d96df77890c79f792d3f203e932f3a8766bfc9bf",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5996dfe1_99a25d73",
        "filename": "reaper.cpp",
        "patchSetId": 6
      },
      "lineNbr": 167,
      "author": {
        "id": 1157738
      },
      "writtenOn": "2021-12-29T00:05:00Z",
      "side": 1,
      "message": "Good catch! I forgot to add it after replacing unique_lock with direct mutex_.lock() for more granular locking control. Will fix.",
      "parentUuid": "31e456ad_41555326",
      "range": {
        "startLine": 167,
        "startChar": 15,
        "endLine": 167,
        "endChar": 20
      },
      "revId": "d96df77890c79f792d3f203e932f3a8766bfc9bf",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dbde7d8f_a3eea5cb",
        "filename": "reaper.cpp",
        "patchSetId": 6
      },
      "lineNbr": 177,
      "author": {
        "id": 1499410
      },
      "writtenOn": "2021-12-23T18:37:21Z",
      "side": 1,
      "message": "Can unlock before the notify_one() to prevent the reaper thread  waking up to immediately wait again on the lock we are still holding.",
      "range": {
        "startLine": 177,
        "startChar": 4,
        "endLine": 177,
        "endChar": 20
      },
      "revId": "d96df77890c79f792d3f203e932f3a8766bfc9bf",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "60a3f6f6_f8d239e2",
        "filename": "reaper.cpp",
        "patchSetId": 6
      },
      "lineNbr": 177,
      "author": {
        "id": 1157738
      },
      "writtenOn": "2021-12-23T18:56:09Z",
      "side": 1,
      "message": "This is the standard pattern for signalling to avoid races. See discussion in https://stackoverflow.com/questions/4544234/calling-pthread-cond-signal-without-locking-mutex for explanation.",
      "parentUuid": "dbde7d8f_a3eea5cb",
      "range": {
        "startLine": 177,
        "startChar": 4,
        "endLine": 177,
        "endChar": 20
      },
      "revId": "d96df77890c79f792d3f203e932f3a8766bfc9bf",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5289ecb0_4b60071e",
        "filename": "reaper.cpp",
        "patchSetId": 6
      },
      "lineNbr": 177,
      "author": {
        "id": 1499410
      },
      "writtenOn": "2021-12-23T20:01:07Z",
      "side": 1,
      "message": "Ack, this is ok too. (Discussion also notes we can do the signal after the unlock)",
      "parentUuid": "60a3f6f6_f8d239e2",
      "range": {
        "startLine": 177,
        "startChar": 4,
        "endLine": 177,
        "endChar": 20
      },
      "revId": "d96df77890c79f792d3f203e932f3a8766bfc9bf",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}