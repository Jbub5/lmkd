{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "5f01713a_eb51c942",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 16
      },
      "lineNbr": 0,
      "author": {
        "id": 1275554
      },
      "writtenOn": "2022-01-04T17:42:01Z",
      "side": 1,
      "message": "Do we need watchdog class for this? Why can\u0027t we use just a timer instance?\n\nWhenever LMKD is dealing with events, it could set up the timer in prologue and then remove the timer in epilogue. If it takes to handle the event too long, the timer will be triggered and then find an victim and asking to kill it to the reaper. \nDo I miss something here?",
      "revId": "1bfbc279d6a521dc6a05a86aae8c0e00dde6bb9e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6ad1f211_8cd268ea",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 16
      },
      "lineNbr": 0,
      "author": {
        "id": 1157738
      },
      "writtenOn": "2022-01-04T18:28:34Z",
      "side": 1,
      "message": "I considered using settimer syscall but it would interrupt the main thread when the signal is delivered (see: https://man7.org/linux/man-pages/man7/signal.7.html). What I want to do here is to keep the main thread execution intact and just generate additional kill whenever that execution takes longer than expected.",
      "parentUuid": "5f01713a_eb51c942",
      "revId": "1bfbc279d6a521dc6a05a86aae8c0e00dde6bb9e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6bc952d1_2c0bcf08",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 16
      },
      "lineNbr": 0,
      "author": {
        "id": 1157738
      },
      "writtenOn": "2022-01-04T18:35:20Z",
      "side": 1,
      "message": "One more important point. In the case when the main thread gets into an uninterruptible sleep, I think the signal will not be delivered until that sleep is over. So, that would render the watchdog useless for that kind of blockage.",
      "parentUuid": "6ad1f211_8cd268ea",
      "revId": "1bfbc279d6a521dc6a05a86aae8c0e00dde6bb9e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "69cdffcf_1a25cc0b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 16
      },
      "lineNbr": 0,
      "author": {
        "id": 1275554
      },
      "writtenOn": "2022-01-04T20:05:23Z",
      "side": 1,
      "message": "timer_create supports SIGEV_THREAD_ID based on man page. If I understand correctly, it will wake up a specific thread when the timer is expired. Then, we could create a thread who will just kill target under heavy memory pressure(iow, watchdog_thread). And main would just setup/teardown the timer in the event handler.",
      "parentUuid": "6bc952d1_2c0bcf08",
      "revId": "1bfbc279d6a521dc6a05a86aae8c0e00dde6bb9e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d2d51289_df0c66fe",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 16
      },
      "lineNbr": 0,
      "author": {
        "id": 1157738
      },
      "writtenOn": "2022-01-04T20:24:30Z",
      "side": 1,
      "message": "I see. I haven\u0027t used timer_create before. Let me try and see if that works. Thanks!",
      "parentUuid": "69cdffcf_1a25cc0b",
      "revId": "1bfbc279d6a521dc6a05a86aae8c0e00dde6bb9e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4e24f3b1_b8cf1eeb",
        "filename": "lmkd.cpp",
        "patchSetId": 16
      },
      "lineNbr": 2075,
      "author": {
        "id": 1275554
      },
      "writtenOn": "2022-01-04T20:05:23Z",
      "side": 1,
      "message": "I think it\u0027s worth to factor out by struct target_proc find_victim function.",
      "range": {
        "startLine": 2053,
        "startChar": 0,
        "endLine": 2075,
        "endChar": 0
      },
      "revId": "1bfbc279d6a521dc6a05a86aae8c0e00dde6bb9e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ca143c16_65d0b288",
        "filename": "lmkd.cpp",
        "patchSetId": 16
      },
      "lineNbr": 2075,
      "author": {
        "id": 1157738
      },
      "writtenOn": "2022-01-04T20:24:30Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "4e24f3b1_b8cf1eeb",
      "range": {
        "startLine": 2053,
        "startChar": 0,
        "endLine": 2075,
        "endChar": 0
      },
      "revId": "1bfbc279d6a521dc6a05a86aae8c0e00dde6bb9e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}